#!/bin/bash

tell() {
  printf "\033[1;33m|-- ${*}\033[0m\n"
  $* || {
    printf "\033[0m"
  }
}

explain() {
  printf "\033[1;34m${1}\033[0m\n"
}

explain2() {
  printf "\033[1;33m|-- ${1}\033[0m\n"
}

success() {
  printf "\033[1;32m${1}\033[0m\n"
}

error() {
  printf "\033[1;31m${1}\033[0m\n"
}

run_with_spinner() {
    local cmd="${*}"
    local logfile="/tmp/command_$(date +%s).log"
    local spinner='|/-\'
    local i=0
    local pid pgid

    if [ ! -z "${I_TITLE}" ]; then
        explain2 "$I_TITLE"
        unset I_TITLE
    else
        explain2 "$cmd"
    fi
    [ -f /tmp/log_install_last ] && rm -f /tmp/log_install_last
    ln -s "$logfile" /tmp/log_install_last

    # Run the command in a separate process group
    bash -c "$cmd" &> "$logfile" &
    pid=$!
    pgid=$(ps -o pgid= "$pid" | tr -d ' ')

    # Trap Ctrl-C: kill the entire process group (bash -c and all its children)
    trap '
        printf "\n"
        echo "Aborted by user. Killing process group $pgid..."
        kill -TERM -$pgid 2>/dev/null
        wait $pid 2>/dev/null
        return 130
    ' INT

    # Spinner loop
    while kill -0 "$pid" 2>/dev/null; do
        i=$(( (i+1) % 4 ))
        printf "\r[%c] " "${spinner:$i:1}"
        sleep 0.1
    done

    # Wait for completion
    wait "$pid"
    local cmdstatus=$?

    # Clear spinner and trap
    trap - INT
    printf "\r"

    if [ $cmdstatus -ne 0 ]; then
        error "Command failed with exit code ${cmdstatus}:"
        tail -n 10 "$logfile"
        echo "Full log available at: $logfile"
    fi

    return $cmdstatus
}

apply_sed_to_dotfiles() {
    local dotfiles="$HOME"
    local configs=("zshrc" "bashrc" "profile" "zprofile" "zshenv" "bash_profile")
    local file fullpath

    for file in "${configs[@]}"; do
        fullpath="$dotfiles/.$file"
        if [[ -f "$fullpath" ]]; then
            sed -i "$1" $(realpath "$fullpath")
            # clean up empty last lines
            sed -i ':a;/^\n*$/{$d;N;ba}' $(realpath "$fullpath")
        fi
    done
}

install_github_app() {
    local APP_ALIASES="$1"
    local SITE="$2"
    local GREP_NAME="$3"

    if [ -z "$APP_ALIASES" ] || [ -z "$SITE" ] || [ -z "$GREP_NAME" ]; then
        echo "Usage: install_github_app <app_aliases> <repo_site> <grep_pattern>"
        return 1
    fi

    explain "Installation of $APP_ALIASES"

    # CREATE DIRECTORIES
    local MAIN_NAME
    MAIN_NAME=$(echo "$APP_ALIASES" | cut -d',' -f1 | xargs)  # take first alias as main folder name
    [ -d "$HOME/.local/bin/$MAIN_NAME-bin" ] && rm -rf "$HOME/.local/bin/$MAIN_NAME-bin"
    mkdir -p "$HOME/.local/bin/$MAIN_NAME-bin/tmp" "$HOME/.local/bin/$MAIN_NAME-bin/icons" "$HOME/.local/bin/share" || return 1
    cd "$HOME/.local/bin/$MAIN_NAME-bin/tmp" || return 1

    # DOWNLOAD AND PREPARE THE APP
    local version
    version=$(curl -sS -Ls "https://api.github.com/repos/$SITE/releases" \
              | sed 's/[()",{} ]/\n/g' \
              | grep -oi "$GREP_NAME" \
              | head -1)

    if [ -z "$version" ]; then
        echo "Error: Could not find a release matching $GREP_NAME"
        return 1
    fi

    wget -q --show-progress "$version" || return 1

    # Extract downloaded files
    [ -e ./*tar.* ] && tar fx ./*tar.* && rm -f ./*tar.*
    [ -e ./*zip ] && unzip -qq ./*zip 1>/dev/null && rm -f ./*zip
    [ -e ./*gz ] && gunzip ./*gz && rm -f ./*gz
    [ -e ./*xz ] && unxz ./*xz && rm -f ./*xz
    [ -e ./*7z ] && 7z x ./*7z && rm -f ./*7z

    cd ..

    # Move extracted files
    if [ -d ./tmp/* 2>/dev/null ]; then 
        mv ./tmp/*/* ./ 
    else 
        mv ./tmp/* ./"$MAIN_NAME" 2>/dev/null || mv ./tmp/* ./ 
    fi

    # Cleanup
    rm -rf ./tmp || return 1

    # Write version
    echo "$version" > ./version

    # Link only requested aliases
    cd "$HOME/.local/bin" || return 1
    IFS=',' read -ra ALIASES <<< "$APP_ALIASES"
    for alias in "${ALIASES[@]}"; do
        alias=$(echo "$alias" | xargs)  # trim spaces
        target="$HOME/.local/bin/$MAIN_NAME-bin/$alias"
        if [ -e "$alias" ]; then
            rm -f "$alias"
        fi
        chmod a+x "$target" || return 1
        ln -s "$target" "$alias"
    done
}

get_config_for_current_shell() {
    current_shell=$(basename "$SHELL")
    case $current_shell in
        fish)
            config_files="$HOME/.config/fish/config.fish"
        ;;
        zsh)
            config_files="$HOME/.zshrc $HOME/.zshenv $XDG_CONFIG_HOME/zsh/.zshrc $XDG_CONFIG_HOME/zsh/.zshenv"
        ;;
        bash)
            config_files="$HOME/.bashrc $HOME/.bash_profile $HOME/.profile $XDG_CONFIG_HOME/bash/.bashrc $XDG_CONFIG_HOME/bash/.bash_profile"
        ;;
        ash)
            config_files="$HOME/.ashrc $HOME/.profile"
        ;;
        sh)
            config_files="$HOME/.ashrc $HOME/.profile"
        ;;
        tcsh)
            config_files="$HOME/.tcshrc $HOME/.cshrc $HOME/.login"
        ;;
        csh)
            config_files="$HOME/.cshrc $HOME/.login"
        ;;
        *)
            # Default case if none of the above matches
            config_files="$HOME/.login $HOME/.bashrc $HOME/.bash_profile $XDG_CONFIG_HOME/bash/.bashrc $XDG_CONFIG_HOME/bash/.bash_profile"
        ;;
    esac

    config_file=""
    for file in $config_files; do
        if [[ -f $file ]]; then
            config_file=$file
            break
        fi
    done

    if [[ -z $config_file ]]; then
        echo "$HOME/.login"
    fi
    echo $config_file
}

add_github_key() {
    local user="$1"
    local ssh_dir="$HOME/.ssh"
    local auth_file="$ssh_dir/authorized_keys"

    # Check if username is provided
    if [[ -z "$user" ]]; then
        echo "Usage: add_github_key <github-username>"
        return 1
    fi

    # Create .ssh directory if it doesn't exist
    mkdir -p "$ssh_dir"
    chmod 700 "$ssh_dir"

    # Fetch keys from GitHub
    local keys
    keys=$(curl -fsSL "https://github.com/${user}.keys") || {
        error "Error: Failed to fetch keys for user '$user'"
        return 1
    }

    if [[ -z "$keys" ]]; then
        error "No keys found for GitHub user '$user'."
        return 1
    fi

    # Append keys to authorized_keys (avoid duplicates)
    echo "$keys" | while read -r key; do
        grep -qxF "$key" "$auth_file" 2>/dev/null || echo "$key" >> "$auth_file"
    done

    chmod 600 "$auth_file"
    explain2 "[SSH] Keys from GitHub user '$user' added to $auth_file"
}
