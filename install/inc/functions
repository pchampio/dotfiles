#!/bin/bash

tell() {
  printf "\033[1;33m|-- ${*}\033[0m\n"
  printf "\033[0;31m" 1>&2 ;
  $* || {
    printf "\033[0m"
  }
}

explain() {
  printf "\033[1;34m${1}\033[0m\n"
}

explain2() {
  printf "\033[1;33m|-- ${1}\033[0m\n"
}

success() {
  printf "\033[1;32m${1}\033[0m\n"
}

error() {
  printf "\033[1;31m${1}\033[0m\n"
}

run_with_spinner() {
    local cmd="${*}"
    local logfile="/tmp/command_$(date +%s).log"
    local spinner='|/-\'
    local i=0
    local pid pgid

    if [ ! -z "${I_TITLE}" ]; then
        explain2 "$I_TITLE"
        unset I_TITLE
    else
        explain2 "$cmd"
    fi
    [ -f /tmp/log_install_last ] && rm -f /tmp/log_install_last
    ln -s "$logfile" /tmp/log_install_last

    # Run the command in a separate process group
    bash -c "$cmd" &> "$logfile" &
    pid=$!
    pgid=$(ps -o pgid= "$pid" | tr -d ' ')

    # Trap Ctrl-C: kill the entire process group (bash -c and all its children)
    trap '
        printf "\n"
        echo "Aborted by user. Killing process group $pgid..."
        kill -TERM -$pgid 2>/dev/null
        wait $pid 2>/dev/null
        return 130
    ' INT

    # Spinner loop
    while kill -0 "$pid" 2>/dev/null; do
        i=$(( (i+1) % 4 ))
        printf "\r[%c] " "${spinner:$i:1}"
        sleep 0.1
    done

    # Wait for completion
    wait "$pid"
    local cmdstatus=$?

    # Clear spinner and trap
    trap - INT
    printf "\r"

    if [ $cmdstatus -ne 0 ]; then
        error "Command failed with exit code ${status}:"
        tail -n 10 "$logfile"
        echo "Full log available at: $logfile"
    fi

    return $cmdstatus
}

apply_sed_to_dotfiles() {
    local dotfiles="$HOME"
    local configs=("zshrc" "bashrc" "profile" "zprofile" "zshenv" "bash_profile")
    local file fullpath

    for file in "${configs[@]}"; do
        fullpath="$dotfiles/.$file"
        if [[ -f "$fullpath" ]]; then
            sed -i "$1" $(realpath "$fullpath")
            # clean up empty last lines
            sed -i ':a;/^\n*$/{$d;N;ba}' $(realpath "$fullpath")
        fi
    done
}

install_github_app() {
    local APP_ALIASES="$1"
    local SITE="$2"
    local GREP_NAME="$3"

    if [ -z "$APP_ALIASES" ] || [ -z "$SITE" ] || [ -z "$GREP_NAME" ]; then
        echo "Usage: install_github_app <app_aliases> <repo_site> <grep_pattern>"
        return 1
    fi

    explain "Installation of $APP_ALIASES"

    # CREATE DIRECTORIES
    local MAIN_NAME
    MAIN_NAME=$(echo "$APP_ALIASES" | cut -d',' -f1 | xargs)  # take first alias as main folder name
    [ -d "$HOME/.local/bin/$MAIN_NAME-bin" ] && rm -rf "$HOME/.local/bin/$MAIN_NAME-bin"
    mkdir -p "$HOME/.local/bin/$MAIN_NAME-bin/tmp" "$HOME/.local/bin/$MAIN_NAME-bin/icons" "$HOME/.local/bin/share" || return 1
    cd "$HOME/.local/bin/$MAIN_NAME-bin/tmp" || return 1

    # DOWNLOAD AND PREPARE THE APP
    local version
    version=$(curl -sS -Ls "https://api.github.com/repos/$SITE/releases" \
              | sed 's/[()",{} ]/\n/g' \
              | grep -oi "$GREP_NAME" \
              | head -1)

    if [ -z "$version" ]; then
        echo "Error: Could not find a release matching $GREP_NAME"
        return 1
    fi

    wget -q --show-progress "$version" || return 1

    # Extract downloaded files
    [ -e ./*tar.* ] && tar fx ./*tar.* && rm -f ./*tar.*
    [ -e ./*zip ] && unzip -qq ./*zip 1>/dev/null && rm -f ./*zip
    [ -e ./*gz ] && gunzip ./*gz && rm -f ./*gz
    [ -e ./*xz ] && unxz ./*xz && rm -f ./*xz
    [ -e ./*7z ] && 7z x ./*7z && rm -f ./*7z

    cd ..

    # Move extracted files
    if [ -d ./tmp/* 2>/dev/null ]; then 
        mv ./tmp/*/* ./ 
    else 
        mv ./tmp/* ./"$MAIN_NAME" 2>/dev/null || mv ./tmp/* ./ 
    fi

    # Cleanup
    rm -rf ./tmp || return 1

    # Write version
    echo "$version" > ./version

    # Link only requested aliases
    cd "$HOME/.local/bin" || return 1
    IFS=',' read -ra ALIASES <<< "$APP_ALIASES"
    for alias in "${ALIASES[@]}"; do
        alias=$(echo "$alias" | xargs)  # trim spaces
        target="$HOME/.local/bin/$MAIN_NAME-bin/$alias"
        if [ -e "$alias" ]; then
            rm -f "$alias"
        fi
        chmod a+x "$target" || return 1
        ln -s "$target" "$alias"
    done
}
